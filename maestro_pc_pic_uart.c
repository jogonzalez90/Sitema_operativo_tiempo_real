#include <maestro_pc_pic_uart.h>

     //DECLARACIONES DEFINE
   #DEFINE IDLE_1 PIN_E0

   //VARIBLES A USAR
   INT RS=0;//RS DATO RECIBIDO
   INT AD0=0;//VARIABLE A GUARDAR AD0
   INT AD1=0;//VARIABLE A GUARDAR AD1
   INT AD2=0;//VARIABLE A GUARDAR AD2
   INT AD3=0;//VARIABLE A GUARDAR AD3
   INT DIG=0;//VARIABLE A GUARDAR BYTE DATO DE ENTRADA
   INT CONT=1;//NUMERO DE ATENCIONES RDA
   INT CONT2=1;//NUMERO DE ATENCIONES PARA PASO DE DATOS
   INT D1=0;//PRIMER DATO DIGITADO
   INT D2=0;//SEGUNDO DATO DIGITADO
   INT TEMPAD=0;//VARIALBE A GUARDAR CONTENIDO DE CONVERCION AD
   INT CONTVIS=1;//CONTEO VISULIZACIONES
  
   VOID VISUALIZAR(VOID)//FUNCION PARA VISUALIZAR DATOS
   {
      IF(CONTVIS==1)
      {
         CONTVIS++;
         OUTPUT_D(AD0);//VISUALIZAMOS VALOR AD0
      }
      ELSE
      IF(CONTVIS==2)
      {
         CONTVIS++;
         OUTPUT_D(AD1);//VISUALIZAMOS VALOR AD1
      }
      ELSE
      IF(CONTVIS==3)
      {
         CONTVIS++;
         OUTPUT_D(AD2);//VISUALIZAMOS VALOR AD2
      }
      ELSE
      IF(CONTVIS==4)
      {
         CONTVIS++;
         OUTPUT_D(AD3);//VISUALIZAMOS VALOR AD3
      }
      ELSE
      IF(CONTVIS==5)
      {
         CONTVIS=1;//REINICIAMOS VALOR CONTVIS
         OUTPUT_D(DIG);//VISUALIZAMOS VALOR BYTE
         ENABLE_INTERRUPTS(INT_TIMER2);//HABILITAMOS INTERRUPCION POR TIMER2
         DISABLE_INTERRUPTS(INT_TIMER1);//DESHABILITAMOS INTERRUPCION POR TIMER2
         
         #ASM
            BCF    03.5//BANCO CERO
            BSF    0X1F.2//REINICIO CONVERSION
         #ENDASM
      }
   }
   
   VOID PASO_REGISTROS(VOID)//FUNCION ACTUALIZACION DE DATOS EN REGISTROS
   {
      IF(CONT2==1)
      {
         CONT2++;
         SET_ADC_CHANNEL(1);//CANAL A USAR PARA CONVERSION AN1
         
          #ASM
            BCF    03.5//BANCO CERO
            MOVF   0X31,W//PASO TEMPAD A W
            MOVWF  0X28//PASO W A AD0
            BSF    0X1F.2//REINICIO CONVERSION
         #ENDASM
      }
       ELSE
       IF(CONT2==2)
      {
         CONT2++;
         SET_ADC_CHANNEL(2);//CANAL A USAR PARA CONVERSION AN2
         
          #ASM
            BCF    03.5//BANCO CERO
            MOVF   0X31,W//PASO TEMPAD A W
            MOVWF  0X29//PASO W A AD1
            BSF    0X1F.2//REINICIO CONVERSION
         #ENDASM
      }
      ELSE
      IF(CONT2==3)
      {
         CONT2++;
         SET_ADC_CHANNEL(3);//CANAL A USAR PARA CONVERSION AN3
         
          #ASM
            BCF    03.5//BANCO CERO
            MOVF   0X31,W//PASO TEMPAD A W
            MOVWF  0X2A//PASO W A AD2
            BSF    0X1F.2//REINICIO CONVERSION
         #ENDASM
      }
      ELSE
      IF(CONT2==4)
      {
         CONT2++;
         
          #ASM
            BCF    03.5//BANCO CERO
            MOVF   0X31,W//PASO TEMPAD A W
            MOVWF  0X2B//PASO W A AD3
            BSF    0X1F.2//REINICIO CONVERSION
         #ENDASM
      }
      ELSE
      IF(CONT2==5)
      {
         CONT2=1;//RETORNAMOS VARIABLE A ESTADO INICIAL
         DIG=INPUT_B();//LEEMOS CONTENIDO DE PUERTO B Y PASAMOS VALOR A DIG
         
         #ASM
            BSF    0X1F.2//REINICIO CONVERSION
         #ENDASM
      }
   }
  
   VOID TAREA_1(VOID)//FUNCION PARA DETERMINAR COMBINACION DE TECLAS
   {
      IF(D1==0B01000110 && D2==0B01000101)//COMBINAICON "FE"
      {
         SETUP_TIMER_1 (T1_INTERNAL | T1_DIV_BY_8 );//CONFIGURASM TIMER 1 A 500 MS
         DISABLE_INTERRUPTS(INT_TIMER2);//DESHABILITAMOS INTERRUPCION DESBORDAMIENTO TIMER_2
         ENABLE_INTERRUPTS(INT_TIMER1);//HABILITAMOS INTERRUPCION DESBORDAMIENTO TIMER_1
         SET_TIMER1(0);//INICAMOS TIMER 1 CON VALOR "0"
      }
      ELSE
      IF(D1==0B01000101 && D2==0B01000100)//COMBINAICON "ED"
      {
         OUTPUT_D(INPUT_B());//LEEMOS CONTENIDO DE PUERTO B Y PASAMOS VALOR A SALIDA D
      }
      ELSE
      IF(D1==0B01000110 && D2==0B01000110)//COMBINAICON "FF"
      {
         DISABLE_INTERRUPTS(GLOBAL);//HABILITAMOS INTERRUPCIONES (GLOBALES) PARA BLOQUER SISTEMA
      }
   }
   
   VOID RECP(VOID)//FUNCION PARA GUARDAR DATOS INGRESADOS POR TECLADO
   {
      IF(CONT==1)
      {
         CONT++;
         #ASM
            MOVF   0X2C,W//MOVIMIENTO TEMP AL RESGISTRO DE TRABAJO
            MOVWF  0X2F//MOVIMIENTO DE REGISTRO DE TRABAJO A D1
         #ENDASM
      }
      ELSE
      IF(CONT==2)
      {
         //OUTPUT_HIGH(PIN_D3);
         CONT=1;
         #ASM
            MOVF   0X2C,W//MOVIMIENTO TEMP AL RESGISTRO DE TRABAJO
            MOVWF  0X30//MOVIMIENTO DE REGISTRO DE TRABAJO A D2
         #ENDASM
         TAREA_1();//SALTO A FUNCION TAREA
      }
   }
   
   #INT_RDA//DIRECTIVA INTERRUPCION RECEPCION DATO RS 232 
   VOID RDA_ISR(VOID)
   {
      #ASM
         BCF    03.5
         BCF    0X0C.5
         BCF    0X0C.1
         MOVF   0X1A,W//MOVIMIENTO RCREG AL RESGISTRO DE TRABAJO
         MOVWF  0X2C//PASAMOS VALOR A REGISTRO DIG
      #ENDASM
      RECP();//SALTO A FUNCION RECEPCION
   }
   
   #INT_TIMER1//DIRECTIVA INTERRUPCION TIMER_2
   VOID TIMER1_ISR(VOID)
   {
      #ASM
         BSF    03.5//BANCO UNO
         BSF    0X0C.1
         BCF    0X0C.6
         BCF   03.5
      #ENDASM
      VISUALIZAR();
   }
   
    #INT_TIMER2//DIRECTIVA INTERRUPCION TIMER_2
   VOID TIMER2_ISR(VOID)
   {
      OUTPUT_HIGH(PIN_E2);
      #ASM
         BSF    03.5//BANCO UNO
         MOVF   0X1E,W//PASO ADRESL A W
         BCF    03.5//BANCO CERO
         MOVWF  0X31//PASO W A TEMPAD
      #ENDASM
      
      PASO_REGISTROS();//SALTAMOS A REGISTRO  
   }

void main()
{
   #USE RS232(BAUD=9600, XMIT=PIN_C6, RCV=PIN_C7, BITS=8)//DIRECTIVA USO UART
   
   SETUP_ADC_PORTS(AN0_AN1_AN2_AN3_AN4);//CONFIGURAMOS PINES PARA CONVERCION ANALOGICA 
   SETUP_ADC(ADC_CLOCK_DIV_32);//CONFIGURAMOS VELOCIDAD DE CONVERSION
   SETUP_TIMER_2(T2_DIV_BY_16,255,1);//CONFIGUARMOS TIMER_2
   
   ENABLE_INTERRUPTS(INT_TIMER2);//HABILITAMOS INTERRUPCION DESBORDAMIENTO TIMER_2
   ENABLE_INTERRUPTS(INT_RDA);//HABILITAMOS INTERRUPCION RECEPCION DATO RS 232
   ENABLE_INTERRUPTS(GLOBAL);//HABILITAMOS INTERRUPCIONES (GLOBALES)
   
   //JUSTIFICACION A LA DERECHA DE ADRESH Y ADRESL
   #ASM
      BSF    3.5
      BSF    0X1F.7
      BCF    3.5
   #ENDASM
   
   SET_ADC_CHANNEL(0);//CANAL A USAR PARA PRIMERA CONVERSION AN0

   //CONFIGURAMOS PUERTOS
   SET_TRIS_B(0B11111111);
   SET_TRIS_D(0);
   SET_TRIS_E(0B000);
    
   //INICIALIZAMOS SALIDAS
   OUTPUT_D(0);
   OUTPUT_E(0); 
   
   while(TRUE)//FUNCION PRINCIPAL
   {
      //TAREA OCIOSA
      OUTPUT_HIGH(IDLE_1);
      DELAY_MS(200);
      OUTPUT_LOW(IDLE_1);
      DELAY_MS(200);
   }
}

